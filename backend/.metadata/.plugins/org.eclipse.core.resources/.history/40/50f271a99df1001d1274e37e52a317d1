package com.cg.ads.serviceimpl;

import java.util.ArrayList;
import java.util.List;

import org.modelmapper.ModelMapper;
import org.modelmapper.TypeToken;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

import com.cg.ads.dto.ProductAdDto;
import com.cg.ads.dto.ProductCategoryDto;
import com.cg.ads.dto.ProductAdDto;
import com.cg.ads.entity.ProductAd;
import com.cg.ads.repository.ProductAdRepo;
import com.cg.ads.service.ProductAdService;

@Service
public class ProductAdServiceImpl implements ProductAdService {
	private final static String BY_NAME = "name";
	private final static String BY_DATE = "date";
	private final static String BY_PRICE = "price";
	private final static int ITEM_PER_PAGE = 20;

	@Autowired
	private ProductAdRepo productRepo;
	
	@Autowired
	private ModelMapper mapper;

	@Override
	public List<ProductAdDto> get() {
		return mapper.map(productRepo.findAll(), new TypeToken<List<ProductAdDto>>() {
		}.getType());
	}

	@Override
	public List<ProductAdDto> get(int page) {
		Pageable pageable = PageRequest.of(page, ITEM_PER_PAGE);
		return mapper.map(productRepo.findAll(pageable), new TypeToken<List<ProductAdDto>>() {
		}.getType());
	}

	@Override
	public List<ProductAdDto> get(String by, String order, int page) {
		List<ProductAd> products = new ArrayList<>();
		Pageable pageable = PageRequest.of(page, ITEM_PER_PAGE);
		boolean asc = order.equalsIgnoreCase("asc");
		switch (by) {
		case BY_NAME:
			products = asc ? productRepo.findAllByOrderByTitleAsc(pageable)
					: productRepo.findAllByOrderByTitleDesc(pageable);
			break;

		case BY_DATE:
			products = asc ? productRepo.findAllByOrderByUpdatedAtAsc(pageable)
					: productRepo.findAllByOrderByUpdatedAtDesc(pageable);
			break;

		case BY_PRICE:
			products = asc ? productRepo.findAllByOrderByPriceAsc(pageable)
					: productRepo.findAllByOrderByPriceDesc(pageable);
			break;
		}
		return mapper.map(products, new TypeToken<List<ProductAdDto>>() {
		}.getType());
	}

	@Override
	public List<ProductAdDto> get(String query, int page) {
		Pageable pageable = PageRequest.of(page, ITEM_PER_PAGE);
		return mapper.map(productRepo.findByTitleContainingIgnoreCase(query, pageable),
				new TypeToken<List<ProductAdDto>>() {
				}.getType());
	}

	@Override
	public ProductAdDto get(Long productId) {
		ProductAd product = productRepo.findById(productId).orElseThrow(() -> new RuntimeException("Product not found"));
		return mapper.map(product, ProductAdDto.class);
	}

	@Override
	public ProductAdDto add(ProductAdDto dto) {
		return mapper.map(productRepo.save(mapper.map(dto, ProductAd.class)), ProductAdDto.class);
	}

	@Override
	public ProductAdDto update(ProductAdDto dto) {
		ProductAd product = productRepo.findById(dto.getProductId())
				.orElseThrow(() -> new RuntimeException("Product not found"));

		if (product.getTitle() != null && !product.getTitle().equals(dto.getTitle()))
			product.setTitle(dto.getTitle());

		if (product.getPrice() != dto.getPrice())
			product.setPrice(dto.getPrice());

		if (product.getQuantity() != dto.getQuantity())
			product.setQuantity(dto.getQuantity());

		if (product.getCategoryId() != null && !product.getCategoryId().equals(dto.getCategoryId())) {
			
		}

		return mapper.map(productRepo.save(product), ProductAdDto.class);
	}

	@Override
	public Object delete(Long productId) {
		ProductAd product = productRepo.findById(productId).orElseThrow(() -> new RuntimeException("Product not found"));
		productRepo.deleteById(productId);
		return mapper.map(product, ProductAdDto.class);
	}

	@Override
	public Object getByUser(Long adId) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object add(ProductAdDto dto) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Object update(ProductAdDto dto) {
		// TODO Auto-generated method stub
		return null;
	}

}
